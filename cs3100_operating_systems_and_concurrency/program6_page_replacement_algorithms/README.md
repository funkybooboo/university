# CS3100_Program6

Assignment

Develop a simulation that exercises FIFO, LRU, and MRU page replacement on randomly generated page usage sequences.  Your simulator will track the number of page faults generated by each algorithm over the page sequences.  Run the simulation over a range of memory sizes.  After performing the simulations, your program reports how many times each of the algorithms had the fewest number of page faults, along with the number of times Belady's Anomaly occurred; we are told the anomaly occurs only with FIFO, and your program will prove this point by checking for it on all three algorithms.

Keep in mind that this program merely simulates a page replacement system.  Your program doesn't actually create pages of memory, store data in them or move them between frames and the backing store.

Section 10.4 of the textbook works through a few page-replacement scenarios using the page-reference string 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0 over three frames of memory.  This program does the same thing on a larger scale.  Before you write any code first work through the textbook examples by hand until you understand what's happening. For those of you who opted out of the textbook, these are the same examples I worked through on the videos from before Thanksgiving.

Your simulation must meet these specifications:

    Use a thread pool (Executors.newFixedThreadPool(...)) to execute individual simulation tasks.  Create as many workers as there are processors available on the system.
        https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/concurrent/ExecutorService.html 

        Links to an external site.
        We did this in class a few weeks ago as well.
    Create three classes that implement the Runnable interface, each representing a page replacement algorithm
        TaskFIFO
        TaskLRU
        TaskMRU
    The constructors for each of these classes look like...
        public TaskFIFO(int[] sequence, int maxMemoryFrames, int maxPageReference, int[] pageFaults)
            sequence : (input) a randomly generated sequence of page references
            maxMemoryFrames : (input) the number of frames of memory available
            maxPageReference : (input) the maximum page reference possible in the sequence
            pageFaults : (output) an array used to record the number of page faults that occur each simulation of some number of frames.  Each call to the 'run' method of a task results in storing the number of page faults for the task using something like: pageFaults[maxMemoryFrames] = pageFaults (where pageFaults is the number of page faults your code detects).

The program runs 1,000 simulations.  For each simulation the program will generate a randomized page reference sequence of 1,000 items, where a page reference is an integer in the interval [1, 250].  For this page reference sequence, the program should try each page-replacement algorithm against different sizes of memory going from 1 frame up to and including 100 frames.
Simulation pseudo code

    For each simulation (from 1 to 1000)
        Generate a randomized page reference sequence p of length 1000 with page references drawn from the interval [1, 250].  Some page references will be repeated while some page references might not occur.
        For each count of main memory frames f (from 1 to 100)
            Create a FIFO simulation task, e.g. Runnable fifo = new TaskFIFO(p, f, 250, pageFaults)
            Create a LRU simulation task, e.g. Runnable lru = new TaskLRU(p, f, 250, pageFaults)
            Create a MRU simulation task, e.g. Runnable mru = new TaskMRU(p, f, 250, pageFaults)
            Add these Runnable objects to the thread pool for execution
    Wait for the tasks to complete
    Report the total simulation time (in milliseconds)
    Summarize the results
        Report how many times each algorithm had the lowest number of page faults for a particular page reference sequence and frame size.
        There can be ties; if all three algorithms perform equally well, then count all 3 as reaching the minimum.
        Count the number of times Belady's Anomaly occurred, reporting as shown in the example below.

Summarizing The Results

This is how to report the results.  1,000 random page reference strings are generated.  For each page reference string, 100 tests are performed, 1 for each number of frames of physical memory from 1 to 100.  Every test tries each of the FIFO, LRU, and MRU algorithms to count the number of page replacements resulting from the random page reference string applied to the number of frames of memory.  This gives a total of 100,000 tests, each of which finds 3 page replacements counts.

For each of the 100,000 tests, find out how many times FIFO had the fewest number of pages faults.  In the results below, you see that happened 31,771 times out of 100,000 simulations.  Do the same for LRU and MRU.  In the results below you see they have 32,372 and 47,824 respectively.

If you total these three values you'll notice they add up to more than 100,000.  How can that be?  There can be ties, including three-way ties.  When there is a tie for the lowest number of page faults, a win is counted for each algorithm.
