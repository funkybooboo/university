{
  "q1": {
    "prompt": "What is the primary difference between a unique_ptr and a shared_ptr in C++?",
    "answer": ["unique_ptr provides exclusive ownership, while shared_ptr allows multiple pointers to manage the same resource"],
    "distractors": [
      "unique_ptr is faster than shared_ptr", 
      "shared_ptr can be converted to unique_ptr directly", 
      "unique_ptr supports weak references",
      "There is no significant difference between them"
    ]
  },
  "q2": {
    "prompt": "Consider the following lambda expression: [&x](int y) { x += y; }. What does the capture [&x] mean?",
    "answer": ["The lambda captures the variable x by reference, allowing modification of the original variable"],
    "distractors": [
      "The lambda creates a copy of x",
      "The lambda captures x as a const reference",
      "The lambda cannot modify x",
      "The capture means x is passed by value"
    ]
  },
  "q3": {
    "prompt": "Which of the following is true about move constructors in C++?",
    "answer": ["They transfer resources from one object to another, leaving the source object in a non-useful state"],
    "distractors": [
      "They create a deep copy of an object",
      "They are called only for temporary objects",
      "They always create a new memory allocation",
      "They cannot be used with non-pointer members"
    ]
  },
  "q4": {
    "prompt": "What does the '=' operator do when overloaded for a custom class?",
    "answer": ["Defines the assignment operation for objects of the class"],
    "distractors": [
      "Creates a new object",
      "Compares two objects",
      "Moves resources between objects",
      "Deletes the object"
    ]
  },
  "q5": {
    "prompt": "Which of the following best describes polymorphism in C++?",
    "answer": ["The ability of objects of different types to respond to the same method call differently"],
    "distractors": [
      "Creating multiple constructors for a class",
      "Inheriting all methods from a base class",
      "Overloading operators",
      "Creating template classes"
    ]
  },
  "q6": {
    "prompt": "What does the '= default' specifier do when declared for a special member function?",
    "answer": ["Tells the compiler to generate the default implementation of the function"],
    "distractors": [
      "Makes the function inline",
      "Prevents the function from being called",
      "Creates a pure virtual function",
      "Marks the function as deprecated"
    ]
  },
  "q7": {
    "prompt": "In template programming, what does the typename keyword typically signify?",
    "answer": ["Declares a template type parameter that can be any type"],
    "distractors": [
      "Creates a new type",
      "Limits the template to only class types",
      "Defines a type alias",
      "Checks type compatibility at compile-time"
    ]
  },
  "q8": {
    "prompt": "What is the primary purpose of std::optional in modern C++?",
    "answer": ["To represent an optional value that may or may not be present"],
    "distractors": [
      "To create optional function parameters",
      "To implement nullable pointer semantics",
      "To provide thread-safe value storage",
      "To create default constructor behavior"
    ]
  },
  "q9": {
    "prompt": "What characterizes an iterator in the C++ standard library?",
    "answer": ["An object that allows traversal of container elements and provides access to their values"],
    "distractors": [
      "A pointer to the first element of a container",
      "A method for sorting container elements",
      "A way to create deep copies of containers",
      "A mechanism for dynamic memory allocation"
    ]
  },
  "q10": {
    "prompt": "What does structured binding allow you to do in modern C++?",
    "answer": ["Decompose a tuple or struct into individual variables"],
    "distractors": [
      "Create compile-time constants",
      "Define complex inheritance hierarchies",
      "Implement operator overloading",
      "Generate template metaprograms"
    ]
  },
  "q11": {
    "prompt": "What is the primary benefit of using constexpr in C++?",
    "answer": ["Enables compile-time computation and evaluation of expressions"],
    "distractors": [
      "Makes variables constant",
      "Improves runtime performance",
      "Prevents type conversions",
      "Creates thread-safe variables"
    ]
  },
  "q12": {
    "prompt": "What is a functor in C++?",
    "answer": ["A class that overloads the function call operator (), allowing objects to be called like functions"],
    "distractors": [
      "A function that creates functionals",
      "A lambda expression",
      "A template specialization",
      "A virtual function"
    ]
  },
  "q13": {
    "prompt": "What is the primary difference between public, protected, and private inheritance?",
    "answer": ["They control the accessibility of base class members in the derived class"],
    "distractors": [
      "They determine object creation methods",
      "They affect memory allocation",
      "They define constructor behavior",
      "They control template instantiation"
    ]
  },
  "q14": {
    "prompt": "What does the R-value reference (&&) primarily enable in C++?",
    "answer": ["Move semantics and perfect forwarding"],
    "distractors": [
      "Creating constant references",
      "Implementing multiple inheritance",
      "Generating compile-time constants",
      "Preventing object copying"
    ]
  },
  "q15": {
    "prompt": "What is a concept in modern C++ (C++20)?",
    "answer": ["A compile-time predicate that constrains template parameters"],
    "distractors": [
      "A way to create runtime polymorphism",
      "An alternative to inheritance",
      "A method for dynamic type checking",
      "A mechanism for creating singleton classes"
    ]
  },
  "q16": {
    "prompt": "What does std::filesystem primarily provide in modern C++?",
    "answer": ["A portable way to interact with file systems and perform file-related operations"],
    "distractors": [
      "A method for serializing objects",
      "A cross-platform networking library",
      "A mechanism for memory management",
      "A way to create database connections"
    ]
  },
  "q17": {
    "prompt": "What does the '= delete' specifier do when used with a member function?",
    "answer": ["Explicitly prevents the compiler from generating the specified function"],
    "distractors": [
      "Marks the function as deprecated",
      "Creates a pure virtual function",
      "Allows infinite function calls",
      "Enables runtime type checking"
    ]
  },
  "q18": {
    "prompt": "What is the primary purpose of std::ranges in modern C++?",
"answer": ["To provide composable range algorithms and views with improved syntax and performance"],
    "distractors": [
      "To create multidimensional arrays",
      "To implement parallel processing",
      "To manage memory allocation",
      "To define custom container types"
    ]
  },
  "q19": {
    "prompt": "What does the capture clause [] in a lambda expression do?",
    "answer": ["Specifies how external variables are captured by the lambda"],
    "distractors": [
      "Defines the lambda's return type",
      "Creates a new scope for the lambda",
      "Limits the lambda's complexity",
      "Determines the lambda's runtime behavior"
    ]
  },
  "q20": {
    "prompt": "What is Return Value Optimization (RVO) in C++?",
    "answer": ["An optimization technique where the compiler eliminates unnecessary copying of objects"],
    "distractors": [
      "A method for creating virtual functions",
      "A technique for memory allocation",
      "A way to implement move semantics",
      "A compile-time type checking mechanism"
    ]
  },
  "q21": {
    "prompt": "What is the primary purpose of a copy constructor?",
    "answer": ["To create a new object as a copy of an existing object"],
    "distractors": [
      "To move resources between objects",
      "To create default object initialization",
      "To implement runtime polymorphism",
      "To prevent object creation"
    ]
  },
  "q22": {
    "prompt": "In the context of C++ templates, what is template specialization?",
    "answer": ["A way to provide a specific implementation for a particular type or set of types"],
    "distractors": [
      "A method for creating runtime polymorphism",
      "A technique for memory management",
      "A way to limit template instantiation",
      "A mechanism for creating default constructors"
    ]
  },
  "q23": {
      "prompt": "What will be the output of the following code?\n```cpp\nint x = 10;\nauto y = [&x]() { x *= 2; return x; }();\nstd::cout << x << ' ' << y;\n```",
      "answer": ["20 20"],
      "distractors": [
        "10 20",
        "20 10", 
        "10 10",
        "Compilation error"
      ]
    },
    "q24": {
      "prompt": "Which of the following is a valid syntax for a function template with a trailing return type?",
      "answer": ["template <typename T> auto func(T x) -> decltype(x + 1)"],
      "distractors": [
        "template <typename T> decltype(x + 1) func(T x)",
        "template <typename T> auto func(T x) -> T + 1",
        "template <typename T> func(T x) -> decltype(x)",
        "template <typename T> auto func(T x) => decltype(x)"
      ]
  },
  "q25": {
    "prompt": "Consider the following code. What will happen?\n```cpp\nstd::unique_ptr<int> p1(new int(42));\nstd::unique_ptr<int> p2 = std::move(p1);\nif (p1) {\n    std::cout << *p1;\n}\n```",
    "answer": ["Undefined behavior, as p1 is now null after moving"],
    "distractors": [
      "Compilation error",
      "Prints 42",
      "Throws a runtime exception",
      "Segmentation fault"
    ]
  },
  "q26": {
    "prompt": "What will be the output of the following code?\n```cpp\nclass Base {\npublic:\n    virtual void print() { std::cout << \"Base\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void print() override { std::cout << \"Derived\"; }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->print();\n    delete ptr;\n    return 0;\n}\n```",
    "answer": ["Derived"],
    "distractors": [
      "Base",
      "Compilation error",
      "Undefined behavior",
      "Empty output"
    ]
  },
  "q27": {
    "prompt": "Which of the following is a syntactically valid way to declare a variadic template function?",
    "answer": ["template <typename... Args> void func(Args... args)"],
    "distractors": [
      "template <type... Args> void func(Args... args)",
      "template <typename Args...> void func(Args args)",
      "template <typename T> void func(T... args)",
      "template <args... typename> void func(Args... args)"
    ]
  },
  "q28": {
    "prompt": "What does the following code demonstrate?\n```cpp\ntemplate <typename T>\nrequires std::is_integral_v<T>\nT add(T a, T b) {\n    return a + b;\n}\n```",
    "answer": ["A function template with a concept constraint that only works with integral types"],
    "distractors": [
      "A function that adds two floating-point numbers",
      "A compile-time type conversion",
      "A runtime type checking mechanism",
      "An overloaded addition operator"
    ]
  },
  "q29": {
    "prompt": "Consider the syntax: `std::tuple<int, double, std::string> t(10, 3.14, \"hello\");`. How would you use structured bindings to decompose this tuple?",
    "answer": ["auto [x, y, z] = t;"],
    "distractors": [
      "std::tuple_element(t, x, y, z);",
      "std::decompose(t, x, y, z);",
      "auto {x, y, z} = t;",
      "std::unpack(t, x, y, z);"
    ]
  },
  "q30": {
      "prompt": "What is the output of the following code?\n```cpp\ntemplate <typename T>\nclass Widget {\npublic:\n    static int count;\n    Widget() { ++count; }\n    ~Widget() { --count; }\n};\n\ntemplate <typename T>\nint Widget<T>::count = 0;\n\nint main() {\n    Widget<int> w1;\n    Widget<double> w2;\n    Widget<int> w3;\n    std::cout << Widget<int>::count << ' ' << Widget<double>::count;\n    return 0;\n}\n```",
      "answer": ["2 1"],
      "distractors": [
        "1 1",
        "2 2",
        "0 0",
        "Compilation error"
      ]
  }
}
